<빈칸 문제>
1. ( useState )는 가장 기본적인 Hook이며, 함수형 컴포넌트에서도 가변적인 상태를 지닐 수 있게 해 줍니다.
2. ( useEffect )는 클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를 합친 형태로 보아도 무방합니다.
3. ( useReducer )는 현재 상태, 그리고 업데이트를 위해 필요한 정보를 담은 액션(action) 값을 전달받아 새로운 상태를 반환하는 함수입니다.
4. ( useMemo )를 사용하면 함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있습니다.
5. ( useCallback )을 사용하면 이벤트 핸들러 함수를 필요할 때만 생성할 수 있습니다.
6. ( useRef ) Hook은 함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해 줍니다. 
7. 리액트에서 Hooks 패턴을 사용하면 ( 클래스형 ) 컴포넌트를 작성하지 않고도 대부분의 기능을 구현할 수 있습니다.



<빈칸 문제>
1. (              )는 가장 기본적인 Hook이며, 함수형 컴포넌트에서도 가변적인 상태를 지닐 수 있게 해 줍니다.
2. (              )는 클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를 합친 형태로 보아도 무방합니다.
3. (              )는 현재 상태, 그리고 업데이트를 위해 필요한 정보를 담은 액션(action) 값을 전달받아 새로운 상태를 반환하는 함수입니다.
4. (              )를 사용하면 함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있습니다.
5. (              )을 사용하면 이벤트 핸들러 함수를 필요할 때만 생성할 수 있습니다.
6. (              ) Hook은 함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해 줍니다. 
7. 리액트에서 Hooks 패턴을 사용하면 (              ) 컴포넌트를 작성하지 않고도 대부분의 기능을 구현할 수 있습니다.




<코드 문제>


















<코드 정답>